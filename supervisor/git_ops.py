'Supervisor â€” Git operations.\n\nClone, checkout, reset, rescue snapshots, dependency sync, import test.\n'\n\nfrom __future__ import annotations\n\nimport datetime\nimport json\nimport logging\nimport os\nimport pathlib\nimport shutil\nimport subprocess\nimport sys\nimport uuid\nfrom typing import Any, Dict, List, Optional, Tuple\n\nfrom supervisor.state import (\n    load_state, save_state, append_jsonl, atomic_write_text,\n)\n\nlog = logging.getLogger(__name__)\n\n\n# ---------------------------------------------------------------------------\n# Module-level config (set via init())\n# ---------------------------------------------------------------------------\nREPO_DIR: pathlib.Path = pathlib.Path("/content/ouroboros_repo")\nDRIVE_ROOT: pathlib.Path = pathlib.Path("/content/drive/MyDrive/Ouroboros")\nREMOTE_URL: str = ""\nBRANCH_DEV: str = "ouroboros"\nBRANCH_STABLE: str = "ouroboros-stable"\n\n\ndef init(repo_dir: pathlib.Path, drive_root: pathlib.Path, remote_url: str,\n         branch_dev: str = "ouroboros", branch_stable: str = "ouroboros-stable") -> None:\n    global REPO_DIR, DRIVE_ROOT, REMOTE_URL, BRANCH_DEV, BRANCH_STABLE\n    REPO_DIR = repo_dir\n    DRIVE_ROOT = drive_root\n    REMOTE_URL = remote_url\n    BRANCH_DEV = branch_dev\n    BRANCH_STABLE = branch_stable\n\n\n# ---------------------------------------------------------------------------\n# Git helpers\n# ---------------------------------------------------------------------------\n\ndef git_capture(cmd: List[str]) -> Tuple[int, str, str]:\n    r = subprocess.run(cmd, cwd=str(REPO_DIR), capture_output=True, text=True)\n    return r.returncode, (r.stdout or "").strip(), (r.stderr or "").strip()\n\ndef ensure_repo_present() -> None:\n    if not (REPO_DIR / ".git").exists():\n        subprocess.run(["rm", "-rf", str(REPO_DIR)], check=False)\n        subprocess.run(["git", "clone", REMOTE_URL, str(REPO_DIR)], check=True)\n    else:\n        subprocess.run(["git", "remote", "set-url", "origin", REMOTE_URL],\n                        cwd=str(REPO_DIR), check=True)\n    subprocess.run(["git", "config", "user.name", "Ouroboros"], cwd=str(REPO_DIR), check=True)\n    subprocess.run(["git", "config", "user.email", "ouroboros@users.noreply.github.com"],\n                    cwd=str(REPO_DIR), check=True)\n    subprocess.run(["git", "fetch", "origin"], cwd=str(REPO_DIR), check=True)\n\n\n# ---------------------------------------------------------------------------\n# Repo sync state collection\n# ---------------------------------------------------------------------------\n\ndef _collect_repo_sync_state() -> Dict[str, Any]:\n    state: Dict[str, Any] = {\n        "current_branch": "unknown",\n        "dirty_lines": [],\n        "unpushed_lines": [],\n        "warnings": [],\n    }\n\n    rc, branch, err = git_capture(["git", "rev-parse", "--abbrev-ref", "HEAD"])\n    if rc == 0 and branch:\n        state["current_branch"] = branch\n    elif err:\n        state["warnings"].append(f"branch_error:{err}")\n\n    rc, dirty, err = git_capture(["git", "status", "--porcelain"])\n    if rc == 0 and dirty:\n        state["dirty_lines"] = [ln for ln in dirty.splitlines() if ln.strip()]\n    elif rc != 0 and err:\n        state["warnings"].append(f"status_error:{err}")\n\n    upstream = ""\n    rc, up, err = git_capture(["git", "rev-parse", "--abbrev-ref", "--symbolic-full-name", "@{u}"])\n    if rc == 0 and up:\n        upstream = up\n    else:\n        current_branch = str(state.get("current_branch") or "")\n        if current_branch not in ("", "HEAD", "unknown"):\n            upstream = f"origin/{current_branch}"\n        elif err:\n            state["warnings"].append(f"upstream_error:{err}")\n\n    if upstream:\n        rc, unpushed, err = git_capture(["git", "log", "--oneline", f"{upstream}..HEAD"])\n        if rc == 0 and unpushed:\n            state["unpushed_lines"] = [ln for ln in (unpushed.splitlines() or []) if ln.strip()]\n        elif rc != 0 and err:\n            state["warnings"].append(f"unpushed_error:{err}")\n\n    return state\n\n\ndef _copy_untracked_for_rescue(dst_root: pathlib.Path, max_files: int = 200,\n                                max_total_bytes: int = 12_000_000) -> Dict[str, Any]:\n    out: Dict[str, Any] = {\n        "copied_files": 0, "skipped_files": 0, "copied_bytes": 0, "truncated": False,\n    }\n    rc, txt, err = git_capture(["git", "ls-files", "--others", "--exclude-standard"])\n    if rc != 0:\n        out["error"] = err or "git ls-files failed"\n        return out\n\n    lines = [ln.strip() for ln in txt.splitlines() if ln.strip()]\n    if not lines:\n        return out\n\n    dst_root.mkdir(parents=True, exist_ok=True)\n    for rel in lines:\n        if out["copied_files"] >= max_files:\n            out["truncated"] = True\n            break\n        src = (REPO_DIR / rel).resolve()\n        try:\n            src.relative_to(REPO_DIR.resolve())\n        except Exception:\n            out["skipped_files"] += 1\n            continue\n        if not src.exists() or not src.is_file():\n            out["skipped_files"] += 1\n            continue\n        try:\n            size = int(src.stat().st_size)\n        except Exception:\n            out["skipped_files"] += 1\n            continue\n        if (out["copied_bytes"] + size) > max_total_bytes:\n            out["truncated"] = True\n            break\n        dst = dst_root / rel\n        dst.parent.mkdir(parents=True, exist_ok=True)\n        try:\n            shutil.copy2(src, dst)\n            out["copied_files"] += 1\n            out["copied_bytes"] += size\n        except Exception:\n            out["skipped_files"] += 1\n    return out\n\n\ndef _create_rescue_snapshot(branch: str, reason: str,\n                             repo_state: Dict[str, Any]) -> Dict[str, Any]:\n    now = datetime.datetime.now(datetime.timezone.utc)\n    ts = now.strftime("%Y%m%d_%H%M%S")\n    rescue_dir = DRIVE_ROOT / "archive" / "rescue" / f"{ts}_{uuid.uuid4().hex[:8]}"\n    rescue_dir.mkdir(parents=True, exist_ok=True)\n\n    info: Dict[str, Any] = {\n        "ts": now.isoformat(),\n        "target_branch": branch,\n        "reason": reason,\n        "current_branch": repo_state.get("current_branch"),\n        "dirty_count": len(repo_state.get("dirty_lines") or []),\n        "unpushed_count": len(repo_state.get("unpushed_lines") or []),\n        "warnings": list(repo_state.get("warnings") or []),\n        "path": str(rescue_dir),\n    }\n\n    rc_status, status_txt, _ = git_capture(["git", "status", "--porcelain"])\n    if rc_status == 0:\n        atomic_write_text(rescue_dir / "status.porcelain.txt",\n                          status_txt + ("\n" if status_txt else ""))\n\n    rc_diff, diff_txt, diff_err = git_capture(["git", "diff", "--binary", "HEAD"])\n    if rc_diff == 0:\n        atomic_write_text(rescue_dir / "changes.diff",\n                          diff_txt + ("\n" if diff_txt else ""))\n    else:\n        info["diff_error"] = diff_err or "git diff failed"\n\n    untracked_meta = _copy_untracked_for_rescue(rescue_dir / "untracked")\n    info["untracked"] = untracked_meta\n\n    unpushed_lines = [ln for ln in (repo_state.get("unpushed_lines") or []) if str(ln).strip()]\n    if unpushed_lines:\n        atomic_write_text(rescue_dir / "unpushed_commits.txt",\n                          "\n".join(unpushed_lines) + "\n")\n\n    atomic_write_text(rescue_dir / "rescue_meta.json",\n                      json.dumps(info, ensure_ascii=False, indent=2))\n    return info\n\n\n# ---------------------------------------------------------------------------\n# Checkout + reset\n# ---------------------------------------------------------------------------\n\ndef checkout_and_reset(branch: str, reason: str = "unspecified",\n                       unsynced_policy: str = "ignore") -> Tuple[bool, str]:\n    rc, _, err = git_capture(["git", "fetch", "origin"])\n    if rc != 0:\n        msg = f"git fetch failed: {err or 'unknown error'}"\n        append_jsonl(\n            DRIVE_ROOT / "logs" / "supervisor.jsonl",\n            {\n                "ts": datetime.datetime.now(datetime.timezone.utc).isoformat(),\n                "type": "reset_fetch_failed",\n                "target_branch": branch, "reason": reason, "error": msg,\n            },\n        )\n        return False, msg\n\n    policy = str(unsynced_policy or "ignore").strip().lower()\n    if policy not in {"ignore", "block", "rescue_and_block", "rescue_and_reset"}:\n        policy = "ignore"\n\n    repo_state = _collect_repo_sync_state()\n    dirty_lines = list(repo_state.get("dirty_lines") or [])\n    unpushed_lines = list(repo_state.get("unpushed_lines") or [])\n    rescue_info: Dict[str, Any] = {}\n\n    if dirty_lines or unpushed_lines:\n        if policy in {"rescue_and_block", "rescue_and_reset"}:\n            try:\n                rescue_info = _create_rescue_snapshot(\n                    branch=branch, reason=reason, repo_state=repo_state)\n            except Exception as e:\n                rescue_info = {"error": repr(e)}\n        bits: List[str] = []\n        if unpushed_lines:\n            bits.append(f"unpushed={len(unpushed_lines)}")\n        if dirty_lines:\n            bits.append(f"dirty={len(dirty_lines)}")\n        detail = ", ".join(bits) if bits else "unsynced"\n        rescue_suffix = ""\n        rescue_path = str(rescue_info.get("path") or "").strip()\n        if rescue_path:\n            rescue_suffix = f" Rescue saved to {rescue_path}."\n        elif policy in {"rescue_and_block", "rescue_and_reset"} and rescue_info.get("error"):\n            rescue_suffix = f" Rescue failed: {rescue_info.get('error')}.")\n\n        if policy in {"block", "rescue_and_block"}:\n            msg = f"Reset blocked ({detail}) to protect local changes.{rescue_suffix}"\n            append_jsonl(\n                DRIVE_ROOT / "logs" / "supervisor.jsonl",\n                {\n                    "ts": datetime.datetime.now(datetime.timezone.utc).isoformat(),\n                    "type": "reset_blocked_unsynced_state",\n                    "target_branch": branch, "reason": reason, "policy": policy,\n                    "current_branch": repo_state.get("current_branch"),\n                    "dirty_count": len(dirty_lines),\n                    "unpushed_count": len(unpushed_lines),\n                    "dirty_preview": dirty_lines[:20],\n                    "unpushed_preview": unpushed_lines[:20],\n                    "warnings": list(repo_state.get("warnings") or []),\n                    "rescue": rescue_info,\n                },\n            )\n            return False, msg\n\n    # Create stable branch if missing\n    if branch == BRANCH_STABLE:\n        rc_check = subprocess.run(\n            ["git", "ls-remote", "--heads", "origin", BRANCH_STABLE],\n            cwd=str(REPO_DIR),\n            capture_output=True,\n        ).returncode\n        if rc_check != 0:\n            log.warning("Stable branch %s missing - creating from dev", BRANCH_STABLE)\n            try:\n                subprocess.run(["git", "checkout", BRANCH_DEV], cwd=str(REPO_DIR), check=True)\n                subprocess.run(["git", "push", "origin", f"{BRANCH_DEV}:{BRANCH_STABLE}"], cwd=str(REPO_DIR), check=True)\n                log.info("Created stable branch %s from %s", BRANCH_STABLE, BRANCH_DEV)\n            except Exception as e:\n                log.error("Failed to create stable branch: %s", repr(e))\n                return False, "Failed to create stable branch"\n\n    # For dev branch, ensure it exists on remote\n    if branch == BRANCH_DEV:\n        rc_verify_remote = subprocess.run(\n            ["git", "ls-remote", "--heads", "origin", BRANCH_DEV],\n            cwd=str(REPO_DIR),\n            capture_output=True,\n        ).returncode\n        if rc_verify_remote != 0:\n            log.warning("Dev branch %s not found on remote - pushing from local", BRANCH_DEV)\n            try:\n                subprocess.run(["git", "push", "-u", "origin", BRANCH_DEV], cwd=str(REPO_DIR), check=True)\n                log.info("Pushed dev branch %s to remote", BRANCH_DEV)\n            except Exception as e:\n                log.error("Failed to push dev branch: %s", repr(e))\n                return False, "Failed to push dev branch"\n\n    rc_verify = subprocess.run(\n        ["git", "rev-parse", "--verify", f"origin/{branch}"],\n        cwd=str(REPO_DIR),\n        capture_output=True,\n    ).returncode\n    if rc_verify != 0:\n        msg = f"Branch {branch} not found on remote"\n        append_jsonl(\n            DRIVE_ROOT / "logs" / "supervisor.jsonl",\n            {\n                "ts": datetime.datetime.now(datetime.timezone.utc).isoformat(),\n                "type": "reset_branch_missing",\n                "target_branch": branch, "reason": reason,\n            },\n        )\n        return False, msg\n\n    subprocess.run(["git", "checkout", branch], cwd=str(REPO_DIR), check=True)\n    subprocess.run(["git", "reset", "--hard", f"origin/{branch}"], cwd=str(REPO_DIR), check=True)\n    # Clean __pycache__ to prevent stale bytecode (git checkout may not update mtime)\n    for p in REPO_DIR.rglob("__pycache__"):\n        shutil.rmtree(p, ignore_errors=True)\n    st = load_state()\n    st["current_branch"] = branch\n    st["current_sha"] = subprocess.run(\n        ["git", "rev-parse", "HEAD"], cwd=str(REPO_DIR),\n        capture_output=True, text=True, check=True,\n    ).stdout.strip()\n    save_state(st)\n    return True, "ok"\n\n\n\n# ---------------------------------------------------------------------------\n# Dependencies + import test\n# ---------------------------------------------------------------------------\n\ndef sync_runtime_dependencies(reason: str) -> Tuple[bool, str]:\n    req_path = REPO_DIR / "requirements.txt"\n    cmd: List[str] = [sys.executable, "-m", "pip", "install", "-q"]\n    source = ""\n    if req_path.exists():\n        cmd += ["-r", str(req_path)]\n        source = f"requirements:{req_path}"\n    else:\n        cmd += ["openai>=1.0.0", "requests"]\n        source = "fallback:minimal"\n    try:\n        subprocess.run(cmd, cwd=str(REPO_DIR), check=True)\n        append_jsonl(\n            DRIVE_ROOT / "logs" / "supervisor.jsonl",\n            {\n                "ts": datetime.datetime.now(datetime.timezone.utc).isoformat(),\n                "type": "deps_sync_ok", "reason": reason, "source": source,\n            },\n        )\n        return True, source\n    except Exception as e:\n        msg = repr(e)\n        append_jsonl(\n            DRIVE_ROOT / "logs" / "supervisor.jsonl",\n            {\n                "ts": datetime.datetime.now(datetime.timezone.utc).isoformat(),\n                "type": "deps_sync_error", "reason": reason, "source": source, "error": msg,\n            },\n        )\n        return False, msg\n\n\ndef import_test() -> Dict[str, Any]:\n    r = subprocess.run(\n        ["python3", "-c", "import ouroboros, ouroboros.agent; print('import_ok')"],\n        cwd=str(REPO_DIR),\n        capture_output=True, text=True,\n    )\n    return {"ok": (r.returncode == 0), "stdout": r.stdout, "stderr": r.stderr,\n            "returncode": r.returncode}\n\n\n# ---------------------------------------------------------------------------\n# Safe restart orchestration\n# ---------------------------------------------------------------------------\n\ndef safe_restart(\n    reason: str,\n    unsynced_policy: str = "rescue_and_reset",\n) -> Tuple[bool, str]:\n    """\n    Attempt to checkout dev branch, sync deps, and verify imports.\n    Falls back to stable branch if dev fails.\n\n    Args:\n        reason: Human-readable reason for the restart (logged to supervisor.jsonl)\n        unsynced_policy: Policy for handling unsynced state (default: "rescue_and_reset")\n\n    Returns:\n        Tuple of (ok: bool, message: str)\n        - If successful: (True, "OK: <branch>")\n        - If failed: (False, "<error description>")\n    """\n    # Try dev branch\n    ok, err = checkout_and_reset(BRANCH_DEV, reason, unsynced_policy=unsynced_policy)\n    if ok:\n        return True, f"OK: {BRANCH_DEV}"\n\n    # Fallback to stable branch\n    ok, err = checkout_and_reset(BRANCH_STABLE, reason, unsynced_policy=unsynced_policy)\n    if ok:\n        return True, f"OK: {BRANCH_STABLE} (fallback)"\n\n    return False, f"Both branches failed: dev={err}, stable=???"\n